\section{扩展阅读}\label{sec:扩展阅读04}
引入光线追踪算法之后，涌现了大量尝试寻找高效方法对其加速的研究，
主要是通过开发改进的光线追踪加速结构。
《\citetitle{10.5555/94788}》\citep{10.5555/94788}中Arvo和Kirk的章节
总结了1989年最新进展并为区分不同光线相交加速方法提供了优秀的分类方案。

\citet{Kirk88theray}引入了\keyindex{元层次}{meta-hierarchies}{}的统一原则。
它们证明了通过让实现的加速数据结构与场景图元遵照相同的接口，
很容易混合与匹配不同的相交加速框架。
pbrt遵循这一模型，因为\refvar{Aggregate}{}继承自基类\refvar{Primitive}{}。

\subsection{网格}\label{sub:网格}
\citet{4056861}引入了均匀网格，
即把场景边界分解为等长网格的空间细分方法。
\citet{10.2312:egtp.19871000}
以及\citet{Cleary1988}描述了更高效的网格遍历方法。
\citet{10.1145/37401.37417}描述了
对该方法的大量改进并证明了网格对于渲染极其复杂场景的用处。
\citet{Jevans1989:23}引入了层次化网格，
即含有许多图元的网格自我细化为小格。
\citet{cazals1995filtering}以及
\citet{576857}为层次化网格开发了更复杂的技术。

\citet{4061545}为网格的并行创建开发了高效算法。
他们的有趣发现之一是随着所用处理核数量的增长，
网格创建性能很快被有效内存带宽所限制。

选择最优网格分辨率对于从网格中获得优异性能很重要。
\citet{4342587}有该话题的优秀论文，
为完全自动化选择分辨率以及在使用层次化网格时决定何时细化为子网格提供了坚实基础。
他们用大量简化假设推导出理论结果，然后证明了这些结果渲染真实世界场景的适用性。
他们的论文也包括对该领域前人工作很好的筛选引用。

\citet{lagae2008compact}基于
哈希法\sidenote{译者注：即hashing，也称散列法。}为均匀网格
描述了一种新颖的表示，它具有的优良性质是不仅每个图元
拥有对网格的单个索引，而且每个网格也只有单个图元索引。
他们证明了该表示有很低的内存使用量且仍然非常高效。

\citet{4634613}证明在透视空间中构建网格，
即投影中心是相机或光源时，能让追踪相机或光源发出的光线高效得多。
尽管该方法需要多种加速结构，但从为不同种类光线专门设计的多种结构中获得的性能提升可以很高。
他们的方法也因在某种意义上是栅格化和光线追踪的中间地带而令人瞩目。

\subsection{包围盒层次}\label{sub:包围盒层次}
\citet{10.1145/360349.360354}首先建议为标准可见曲面确定算法使用包围盒来剔除物体集。
在此基础上，\citet{10.1145/800250.807479}首先为快速光线追踪
的场景表示开发了层次化数据结构，尽管他们的方法依赖于用户去定义层次。
\citet{10.1145/15922.15916}基于用厚板集定界物体实现了最早之一的实用物体细分方法。
\citet{4057175}描述了自动计算包围盒层次的首个算法。
尽管他们的算法是基于依据盒的表面积来估计光线与包围盒相交的概率，
但它比现代SAH BVH算法低效得多。

本章的\refvar{BVHAccel}{}实现基于\citet{4342588}以及\citet{4342598}描述的构建算法。
边界框测试则是\citet{10.1145/1198555.1198748}引入的。
\citet{10.1080/2151237X.2007.10129248}开发了甚至更高效的边界框测试，
当同一光线对许多边界框做相交测试时它进行额外的预计算以换取更高的性能；
我们把实现他们的方法留作习题。

pbrt中用的BVH遍历算法由多位研究者同时开发出来；
见\citet{bouloshaines2006}的批注了解更多细节和背景。
树遍历的另一选项是\citet{10.1145/15922.15916}；
他们维护一个按光线距离排序的节点堆。
在单片存储\sidenote{译者注：原文on-chip memory。}数量相对有限的GPU上，
为每条光线维护一个将要访问的节点的栈可能会有极其高的内存开销。
\citet{10.1145/1071866.1071869}引入了
“无栈”\sidenote{译者注：原文stackless。}kd树遍历算法，
它周期性地从树根开始回溯和搜索以找到下一个要访问的节点而不是显式保存所有要访问的节点。
\citet{10.5555/1921479.1921496}对该方法做了大量改进，
减少了从树根重新遍历的频率并将该方法应用于BVH。

许多研究者已经为构建BVH后提升其质量开发了许多技术。
\citet{10.2312:EGWR:EGSR07:073-084}和\citet{4634624}提出了
对BVH做局部调整的算法，\citet{10.1145/2159616.2159649}在
一个动画的多个坐标系上复用BVH，通过更新包围运动物体的部分来保持其质量。
也见\citet{BittnerFast2013}、\citet{10.1145/2492045.2492055}
以及\citet{BITTNER2015135}了解该领域的最新工作。

当前大多数构建BVH方法都基于自顶向下的树构建，
首先创建树节点然后将图元划分到孩子中并继续递归。
\citet{4634626}证明了另一个方法，
他说明自底向上的构建即首先创建叶子然后聚为父亲节点是可行选项。
\citet{10.1145/2492045.2492054}开发了该方法高效得多的实现并
证明了其对并行实现的适应性。

BVH的一个缺点是即便少量与边界框重合的相对较大图元也会极大降低BVH的效率：
仅因为下沉到叶子的几何体的重合边界框\sidenote{译者注：此句翻译不确定。}，
许多树节点就会重合。\citet{4342593}提出
“分割剪裁”\sidenote{译者注：原文split clipping。}的办法；
提出了树中每个图元只出现一次的约束，
且巨大输入图元的边界框被细分为更紧致的子框集再用于树的构建。
\citet{4634636}观察到有问题的图元是
那些相对于其表面积在其边界框内有大量空白空间的，
所以它们细分了最异常的三角形并报告有巨大性能提升。
\citet{10.1145/1572769.1572771}开发了
在BVH构建期间划分图元的方法，使得当发现SAH开销下降时可以只划分图元。
也见\citet{10.1145/1572769.1572772}理论上
优化BVH划分算法及其与之前方法的关系，
以及\citet{10.1145/2492045.2492055}改进
决定何时分割三角形的准则。
\citet{10.5555/2980009.2980014}开发了一种方法为长细几何体如毛发等构建BVH；
因为这类几何体相对于其边界框体积来说非常细，
在大多数加速结构上它一般都有很差的性能。

BVH的内存要求可以非常大。在我们的实现中，每个节点为32字节。
场景中每个图元至多需要2个BVH树节点，每个图元的总开销可以高达64字节。
\citet{10.5555/2383894.2383909}建议为BVH节点使用更紧实的表示，牺牲一些效率。
首先，他们量化了每个节点中保存的边界框，用8或16字节来编码其相对于节点父亲边界框的位置。
然后，他们使用了{\itshape 隐式索引}\sidenote{译者注：原文implicit indexing。}，
其中节点$i$的孩子在节点数组中的位置为$2i$和$2i+1$（假设分支系数为$2\times$）。
他们证明节约了大量内存，而性能影响适中。
\citet{10.2312:PE:VMV:VMV10:227-234}开发了另一种在空间上高效的BVH表示。
也见\citet{10.5555/1839214.1839242}开发的BVH节点与三角网格的紧实表示。

\citet{10.1111/j.1467-8659.2006.00970.x}为
缓存高效的BVH和kd树布局提出了算法并展示了来自它们的性能提升。
也见\citet{10.5555/1121584}的书籍了解该话题的广泛讨论。

\citet{10.1111/j.1467-8659.2009.01377.x}引入了线性BVH。
\citet{10.5555/1921479.1921493}在树的上层用SAH开发了HLBVH推广型。
他们还注意到莫顿编码值的高位可用于高效寻找图元群集——两种思想都用于我们HLBVH的开发。
\citet{10.1145/2018323.2018333}对HLBVH引入了更多改进，
它们多数都针对GPU实现。

不像HLBVH路线，这里\refvar{BVHAccel}{}中的BVH构建实现没有并行化。
详见\citet{5669303}了解始终利用SAH进行高性能并行BVH构建的方法。

\subsection{kd树}\label{sub:kd树}
\citet{6429331}为光线相交计算引入使用了八叉树。
\citet{kaplan1985use}\sidenote{译者注：未能找到该文献信息。}首先提出了为光线追踪使用kd树。
\citeauthor{kaplan1985use}的树构建算法总是从中间划分节点；
\citet{MacDonald1990}引入了SAH方法，
用相对表面积估计光线-节点遍历概率。
\citet{Naylor1993:27}也写过关于构建优良kd树的一般问题。
\citet{HavranImproving2002}回顾了许多这些问题并介绍了有用的改进。
\citet{hurley2002fast}提出为完全为空的树节点
添加补贴\sidenote{译者注：原文bonus。}因子到SAH中，就像我们的实现中做的那样。
见\citet{Havran2000:PhD}的博士论文了解对于高性能kd树构建和遍历算法的出色综述。


\citet{10.1007/978-3-642-71071-1_4}首次为kd树开发了高效的光线遍历算法。
\citet{ArvoRay1988}也研究了该问题并在《{\itshape\citefield{ArvoRay1988}{journaltitle}}》中一篇笔记里中作了讨论。
\citet{SUNG1992271}为BSP树加速器描述了一种光线遍历算法的实现；
我们的\refvar{KdTreeAccel}{}遍历代码一定程度上是基于它们的。

pbrt中kd树构建算法的渐进复杂度是$O(n\log^2n)$.
\citet{4061547}证明了用一些额外繁琐的实现可以在$O(n\log n)$时间内构建kd-树；
它们为典型场景报告了$2$到$3\times$的构建时间加速。

光线追踪最好的kd树是用“完美划分”\sidenote{译者注：原文perfect splits。}构建的，
每一步中剪裁正插入到树中的图元以适应当前节点的边界。
这避免了一个问题，例如一个物体的边界框可能与节点的边界框相交因而被存储于其中，
然而该物体自己并没有与该节点的边界框相交。
该方法由\citet{HavranImproving2002}提出并
由\citet{hurley2002fast}以及\citet{4061547}进一步讨论。
也见\citet{4634623}。
即便用完美划分，大型图元仍可能存于许多个kd树叶子中；
\citet{10.1111/cgf.12241}建议在内部节点中存储一些图元以解决该问题。

kd树构建往往比BVH构建慢得多（尤其是如果使用了“完美划分”），
所以并行构建算法特别有意义。该领域的最新工作包括
\citet{10.1111/j.1467-8659.2007.01062.x}和
\citet{10.5555/1921479.1921492}，
他们提出了对多处理器有良好扩展性的高效并行kd树构建算法。

\subsection{表面积启发法}\label{sub:表面积启发法2}
自\citet{MacDonald1990}把SAH引入到
光线追踪以来许多研究者已经钻研了对SAH的改进。
\citet{10.2312:egs.20091046}派生出的一个版本是把
光线在空间中均匀分布的假设替换为光线的起点均匀分布于场景的边界框中。
\citet{4634614}引入了新的SAH，
它导致事实上光线一般并不均匀分布但是它们许多都从单个点
或一组相邻点（分别为相机和光源）发出。\citet{4634625}展示了当使用
“邮箱”\sidenote{译者注：原文mailboxing。}优化时应该怎样修改SAH，
而\citet{VINKLER2012283}用关于图元可见性的假设来调整它们的SAH开销。
\citet{10.1111/j.1467-8659.2011.01861.x}派生出
“光线终止表面积启发法”\sidenote{译者注：原文ray termination surface area heuristic。}（RTSAH），
它们用其来为阴影射线调整BVH遍历顺序以更快找到与遮挡物的相交处。
也见\citet{10.2312:sre.20151164}调整SAH以在kd树
遍历时对正被遮挡的阴影射线负责。

计算SAH会开销很大，尤其是当考虑许多不同的划分或图元分割时。
该问题的一个办法是只在候选点子集处计算它——例如，
沿着pbrt中\refvar{BVHAccel}{}里用的桶方法的直线来。
\citet{hurley2002fast}为构建kd树推荐该方法，
而\citet{4061550}详细讨论了它。
\citet{10.1111/j.1467-8659.2007.01062.x}引入了
将三角形全范围而不仅仅是其形心归入统计\sidenote{译者注：原文binning。}的改进。

\citet{4061549}注意到例如若你只需在一点计算SAH，
则你不需要对图元排序而只需对它们做线性扫描以计算图元数量和该点的边界框。
他们证明了用基于其在许多独立点上的值得到的分段二次式来逼近SAH并
用它选择良好划分会得到高效的树。
\citet{4061550}用了类似的近似。

尽管SAH能得到非常高效的kd树和BVH，但明确的是它并不完美：
许多研究者已经注意到遇到有更高SAH估计开销的kd树或BVH比
具有最低估计开销的树给出更好性能的情况并不罕见。
\citet{10.1145/2492045.2492056}调查了他们的一些结果并
提出两个额外启发法帮助解决之；一个考虑了事实上大多数光线始于曲面——
光线起点实际上并不在场景中随机分布，另一个考虑了当多条光线一起穿过层级时
的SIMD\sidenote{译者注：single instruction multiple data，单指令流多数据流。}分散度。
尽管这些新层次在解释为什么给定的树提供了这样的性能上很有效，
但至今也不知道怎样将其与树构建算法搭配。

\subsection{加速结构的其他话题}\label{sub:加速结构的其他话题}
\citet{10.1145/357332.357335}讨论了
为包围盒使用不同形状的权衡方法并建议把物体投影到屏幕上
再使用$z$-缓存区渲染来为相机光线寻找相交处加速。

许多研究者已经研究了划分平面不必是轴对齐时一般BSP树的适用性，就像kd树的那样。
\citet{4342591}用预选的候选划分平面集来构建树，
然而因为比kd树更慢的构建阶段和更慢的遍历，他们的结果在实际中只接近kd树的性能。
\citet{4634637}展示了比现代kd树更快渲染场景的BSP实现但会花非常长的构建时间。

有很多让一组光线一起而不是每次一个遍历加速结构的技术。
该方法（“包追踪”\sidenote{译者注：原文packet tracing。}）是高性能光线追踪的重要组成；
\refsub{包追踪}会更深入地讨论它。

动画图元给光线追踪器带来两个挑战：
第一，如果物体在移动则尝试在多帧动画上复用加速结构的渲染器必须更新加速结构。
\citet{10.2312:egst.20071056}展示了这种情况下怎样渐进更新BVH，
\citet{10.1111/j.1467-8659.2009.01497.x}建议创建相邻图元群集
然后构建这些群集的BVH（因此减轻BVH构建算法的负担）。
第二个问题是对于快速移动的图元，在它们在帧时间上整个运动的边界框可能非常大，
导致有许多不必要的光线-图元相交测试。
关于该问题的著名工作包括\citet{504}加上时间把光线追踪（以及加速的八叉树）推广到四维。
最近Gr\"{u}nschlo\ss{}等\parencite*{10.1145/2018323.2018334}
\sidenote{译者注：参考文献列表中作者名字中的德文字母“\ss{}”错误显示为“SS”，
目前无法解决，请读者见谅。同时欢迎提供解决办法！}
为运动图元开发了针对BVH的改进。
也见\citet{10.2312:egst.20071056}关于光线追踪动画场景的综述论文。

\citet{10.1145/37401.37409}提出了加速结构的新型方法，
他们引入了5D数据结构来同时基于3D空间和2D光线方向进行细分。
\citet{10.1111/j.1467-8659.2008.01269.x}为
使用三角网格描述的场景提出了另一个有趣的方法：
他们计算一个受约束的四面体网格划分\sidenote{译者注：原文tetrahedralization。}，
其中模型的所有三角形面都在四面体网格划分中表示。
然后光线逐步穿过四面体直到它们与来自场景描述的三角形相交。
该方法仍慢于最新kd树和BVH数倍，却是思考该问题的一个新的有趣方式。

在kd树和BVH之间有个有趣的中间地带，树节点为每个子节点持有划分平面而不是只有单个划分平面。
例如，这一改进使得能在像kd树那样的加速结构中作物体划分，
把每个图元放入仅一个子树并允许子树重合，
但仍保留了kd树高效遍历的许多好处。
\citet{10.1007/978-3-642-72617-0_17}\sidenote{译者注：未找到原文引用文献的信息，
译文改用同年同名同第一作者但发表位置不同的文献。}首次
将该改进引入到kd树中用于排序空间数据，命名为“空间kd树”
\sidenote{译者注：原文spatial kd-tree。}(skd-tree)。
skd树最近已经被许多研究者应用到光线追踪，包括
\citet{10.1145/585740.585761}、\citet{10.1145/1283900.1283912}、
\citet{10.5555/2383894.2383912}、
\citet{4061548}以及\citet{2151237X.2006.10129224}。

当使用像网格或kd树的空间划分方法时，图元可能与结构的多个节点重合，
光线可能在其穿过该结构时多次与同一个图元做相交测试。
\citet{Arnaldi1987}以及
\citet{10.2312:egtp.19871000}开发了
“邮箱”技术来解决这个问题：每条光线都给定唯一的整数标识符，
每个图元都记录与之测试的最后一条光线的id。
如果该id匹配，则相交测试是不必要的，可以跳过它。

尽管很高效，但该方法不适用于多线程光线追踪器。
为了解决该问题，\citet{Benthin_2006}建议排序
每条光线的小哈希表以记录最近相交的图元。
\citet{shevtsov2007ray}维护了
最后$n$个相交图元id的小数组并在执行相交测试前线性搜索它。
尽管两种方法仍可能多次检出一些图元，但它们通常剔除了大多数冗余测试。