\section{并行化}\label{sec:并行化}

\subsection{内存连续模型与性能}\label{sub:内存连续模型与性能}

\subsection{原子操作}\label{sub:原子操作}

\subsection{原子浮点值}\label{sub:原子浮点值}
\begin{lstlisting}
`\initcode{Parallel Declarations}{=}\initnext{ParallelDeclarations}`
class `\initvar{AtomicFloat}{}` {
public:
    `\refcode{AtomicFloat Public Methods}{}`
private:
    `\refcode{AtomicFloat Private Data}{}`
};
\end{lstlisting}
\begin{lstlisting}
`\initcode{AtomicFloat Public Methods}{=}\initnext{AtomicFloatPublicMethods}`
explicit `\refvar{AtomicFloat}{}`(`\refvar{Float}{}` v = 0) { bits = `\refvar{FloatToBits}{}`(v); }
\end{lstlisting}
\begin{lstlisting}
`\refcode{AtomicFloat Public Methods}{+=}\lastcode{AtomicFloatPublicMethods}`
void `\initvar{Add}{}`(`\refvar{Float}{}` v) {
    uint32_t oldBits = bits, newBits;
    do {
        newBits = `\refvar{FloatToBits}{}`(`\refvar{BitsToFloat}{}`(oldBits) + v);
    } while (!bits.compare_exchange_weak(oldBits, newBits));
}
\end{lstlisting}
\subsection{并行的for循环}\label{sub:并行的for循环}
\begin{lstlisting}
`\initcode{Parallel Definitions}{=}\initnext{ParallelDefinitions}`
void `\initvar{ParallelFor}{}`(const std::function<void(int)> &func,
        int count, int chunkSize) {
    `\refcode{Run iterations immediately if not using threads or if count is small}{}`
    `\refcode{Launch worker threads if needed}{}`
    `\refcode{Create and enqueue ParallelForLoop for this loop}{}`
    `\refcode{Notify worker threads of work to be done}{}`
    `\refcode{Help out with parallel loop iterations in the current thread}{}`
}
\end{lstlisting}

\begin{lstlisting}
`\refcode{Parallel Declarations}{+=}\lastcode{ParallelDeclarations}{}`
void `\initvar{ParallelFor2D}{}`(std::function<void(`\refvar{Point2i}{}`)> func,
                   const `\refvar{Point2i}{}` &count);
\end{lstlisting}